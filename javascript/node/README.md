# node

## 1

node只是可以运行JavaScript脚本的一个虚拟机，里面包含着v8引擎和读写本地文件的库。为什么我们写的js代码里，window对象仍然生效，是因为在编译过后的js脚本被浏览器获取时，window对象此时就指浏览器本身了。

也就是说，node在服务器运行脚本后，客户端请求资源，实际上返回给浏览器的js文件，仍旧会被浏览器编译一遍，此时js脚本里有什么，浏览器就会如何编译。

简单来讲，node只是个运行js代码的虚拟机（通俗来讲，其中还有一些细节，或者说它被称作虚拟机不太恰当，但此处为了好理解，暂时这么叫），运行在一个主机的某个端口。我们通过ip来与这台主机建立连接后，请求过来的资源，是经过node运行后的js代码。node为我们做的事情只是编译了我们写的效率低的js脚本模块，node把这些模块最终拼接起来，变成一个效率高的js脚本。（此处的效率指代码量）

## 2

我们可以直接写了js脚本，在浏览器里运行，也可以用node运行。

这也是为什么我们可以轻松的进行模块化。如果我们使用commonJS规范，实现这个规范的一个库是browserify，我们在node里全局安装，那么我们写的js代码里就可以随意使用export（）和require（）。

这也就是阮一峰文章里写的，node实现模块化和浏览器，只是差了一个commonjs的实现。

其中也可以使用browserify编译js文件，然后再用浏览器执行编译后的文件。这种方式也被称作预编译。我们也完全可以node某个脚本，因为browserify是全局安装的，在node的环境里是可以执行的，而浏览器获取的文件，也是运行在主机某个端口的node提供的编译后的js文件。

## 3

模块化问题

上面讲到的是不使用babel的情况，babel是把所有不是ES5语法的js文件转换成ES5语法，但转换后，模块化部分使用的是commonjs规范，所以还需要把这个文件转换一步。

也就是：

1. ES6、jsx、tsx（放在src文件夹）
2. ES5，含模块化（commonJS规范）（放在build文件夹）
3. ES5浏览器可执行（放在dist文件夹）

## 4

我们发现，自己去进行模块化的编译，过程是复杂的，所以我们开始使用webpack

